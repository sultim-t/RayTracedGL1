// Copyright (c) 2021 Sultim Tsyrendashiev
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460
#extension GL_EXT_ray_tracing : require

layout (constant_id = 0) const uint maxAlbedoLayerCount = 0;
#define MATERIAL_MAX_ALBEDO_LAYERS maxAlbedoLayerCount

#define DESC_SET_TLAS 0
#define DESC_SET_FRAMEBUFFERS 1
#define DESC_SET_GLOBAL_UNIFORM 2
#define DESC_SET_VERTEX_DATA 3
#define DESC_SET_TEXTURES 4
#define DESC_SET_RANDOM 5
#define DESC_SET_LIGHT_SOURCES 6
#define DESC_SET_CUBEMAPS 7
#define DESC_SET_RENDER_CUBEMAP 8
#define RAYGEN_SHADOW_PAYLOAD
#include "RaygenCommon.h"

// v -- direction to viewer
// n -- surface normal
void getSpecularBounce(
    uint seed, vec3 n, float roughness, 
    vec3 v, out vec3 bounceDirection, inout vec3 throughput)
{
    const vec4 u = getRandomSample(seed, RANDOM_SALT_SPEC_BOUNCE(0));

    // sample microfacet normal
    const vec3 m = sampleSmithGGX(n, v, roughness, u[0], u[1]);

    // light sample; incident vector must point to surface
    const vec3 l = normalize(reflect(-v, m));

    const float nl = max(dot(n, l), 0.0);
    const float nv = max(dot(n, v), 0.0);

    if (nl > 0 && nv > 0)
    {
        bounceDirection = l;
        
        // "Sampling the GGX Distribution of Visible Normals", Heitz
        // equation 19: F * G2(v,l) / G1(v)
        // let G2 be the simplest: G2(v,l) = G1(v) * G1(l)
        // => F * G1(l)
        
        const float F = 1.0f; // getFresnelSchlick(nl, n1, n2);
        const float G1 = G1GGX(l, n, roughness);

        throughput *= G1;
        // throughput *= 1 / specPr;
    }
}

// v -- direction to viewer
// n -- surface normal
void getDiffuseBounce(
    uint seed, vec3 n, float roughness, 
    vec3 v, out vec3 bounceDirection, inout vec3 throughput)
{
    const vec4 u = getRandomSample(seed, RANDOM_SALT_DIFF_BOUNCE(0));

    bounceDirection = sampleLambertian(n, u[0], u[1]);
    throughput *= evalBRDFLambertian(1.0);
    // throughput *= 1 / nonSpecPr;
}

// Traces bounce ray, computes direct illumination in hit point and returns contribution
vec3 processBounce(
    const uint seed, const uint surfInstCustomIndex, const vec3 surfPosition, 
    const vec3 surfNormal, const vec3 surfNormalGeom,
    const float surfRoughness, const vec3 v, const bool isGradientSample,
    const vec3 bounceDirection, inout vec3 throughput)
{
    // got the bounce direction, trace ray
    const ShPayload p = traceIndirectRay(surfInstCustomIndex, surfPosition + surfNormalGeom * 0.01, bounceDirection); 

    if (isPayloadConsistent(p))
    {
        // TODO: emmision

        float hitDistance;
        const ShHitInfo h = getHitInfoBounce(p, surfPosition, surfRoughness, hitDistance);

        // calculate direct illumination only for directional lights in hit position
        vec3 diffuse, specular;
        vec3 dirDiff, dirSpec;
        processDirectionalLight(
            seed, 
            h.instCustomIndex, h.hitPosition, h.normal, h.normalGeom, h.roughness, 
            -bounceDirection, hitDistance,
            isGradientSample, 
            diffuse, specular);

        throughput *= h.albedo;

        return diffuse;
    }
    else
    {
        const vec3 skyColor = getSky(bounceDirection);
        return skyColor;
    }
}

vec3 processSpecular(
    const uint seed, const uint surfInstCustomIndex, const vec3 surfPosition, 
    const vec3 surfNormal, const vec3 surfNormalGeom,
    const float surfRoughness, const vec3 v, const bool isGradientSample)
{
    vec3 throughput = vec3(1.0);
    vec3 bounceDirection;

    getSpecularBounce(seed, surfNormal, surfRoughness, v, bounceDirection, throughput);

    const vec3 l = processBounce(
        seed, surfInstCustomIndex, surfPosition, 
        surfNormal, surfNormalGeom, surfRoughness, 
        v, isGradientSample,
        bounceDirection, throughput);

    const vec3 contribution = throughput * l;
    return contribution;
}

vec3 processIndirectDiffuse(
    const uint seed, const uint surfInstCustomIndex, const vec3 surfPosition, 
    const vec3 surfNormal, const vec3 surfNormalGeom,
    const float surfRoughness, const vec3 v, const bool isGradientSample,
    out vec3 bounceDirection)
{
    vec3 throughput = vec3(1.0);

    getDiffuseBounce(seed, surfNormal, surfRoughness, v, bounceDirection, throughput);

    const vec3 l = processBounce(
        seed, surfInstCustomIndex, surfPosition, 
        surfNormal, surfNormalGeom, surfRoughness, 
        v, isGradientSample,
        bounceDirection, throughput);

    const vec3 contribution = throughput * l;
    return contribution;
}

// v -- direction to viewer
void processIndirectIllumination(
    const ivec2 pix, const uint seed, 
    const uint surfInstCustomIndex, const vec3 surfPosition, 
    const vec3 surfNormal, const vec3 surfNormalGeom,
    const float surfRoughness, const vec3 v, const bool isGradientSample)
{
    {
        const vec3 contribution = processSpecular(
            seed, surfInstCustomIndex, surfPosition, 
            surfNormal, surfNormalGeom, surfRoughness, 
            v, isGradientSample);

        vec3 spec = imageLoad(framebufUnfilteredSpecular, pix).rgb;
        spec += contribution;

        imageStore(framebufUnfilteredSpecular, pix, vec4(spec, 0.0));
    }

    {
        vec3 bounceDirection;

        const vec3 contribution = processIndirectDiffuse(
            seed, surfInstCustomIndex, surfPosition, 
            surfNormal, surfNormalGeom, surfRoughness, 
            v, isGradientSample,
            bounceDirection);

        const SH bounceSh = irradianceToSH(contribution, bounceDirection);

        // SH sh = imageLoadUnfilteredIndirectSH(pix);
        // accumulateSH(sh, bounceSh, 1.0);

        imageStoreUnfilteredIndirectSH(pix, bounceSh);
    }
}

void main()
{
    const ivec2 pix = ivec2(gl_LaunchIDEXT.xy);

    const float depth = texelFetch(framebufDepth_Sampler, pix, 0).r;

    if (depth > MAX_RAY_LENGTH)
    {
        return;
    }
    
    const uint seed = getCurrentRandomSeed(pix);

    const vec4 surfPosition           = texelFetch(framebufSurfacePosition_Sampler, pix, 0);
    const vec3 surfNormal             = texelFetchNormal(pix);
    const vec3 surfNormalGeom         = texelFetchNormalGeometry(pix);
    const vec4 surfMetallicRoughness  = texelFetch(framebufMetallicRoughness_Sampler, pix, 0);
    const vec4 viewDirection          = texelFetch(framebufViewDirection_Sampler, pix, 0);
    const uint grFB                   = texelFetch(framebufGradientSamples_Sampler, pix / COMPUTE_ASVGF_STRATA_SIZE, 0).x;
    const float surfRoughness         = surfMetallicRoughness.g;
    const uint surfInstCustomIndex    = floatBitsToUint(surfPosition.a);
  
    const bool isGradientSample       = (pix.x % COMPUTE_ASVGF_STRATA_SIZE) == (grFB % COMPUTE_ASVGF_STRATA_SIZE) &&
                                        (pix.y % COMPUTE_ASVGF_STRATA_SIZE) == (grFB / COMPUTE_ASVGF_STRATA_SIZE);

    processIndirectIllumination(pix, seed, surfInstCustomIndex, surfPosition.xyz, surfNormal, surfNormalGeom, surfRoughness, -viewDirection.xyz, isGradientSample);        
}